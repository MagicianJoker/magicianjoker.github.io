---
title: "Unity架构猜想"
subtitle: "「猜想」规划"
layout: post
author: "MagicianJoker"
header-style: text
tags:
  - Unity
---

# Unity客户端架构猜想

## 优秀的插件资源

工欲善其事必先利其器，好的东西，拿来主义

造轮子与拿来主义的决择（重造的意义，拿来主义的方便。有效性，方便性，高效性）



---

## 网络层框架 

- 长连接：TCP+Protobuf    （C#层，Lua层） 

- 短链接：Http+json 



---

## 资源管理与加载 

AssetBundle

- AB包
- 图集


---

## 对象池管理



---

## 消息事件系统

C#层委托，Lua层自做事件系统



---

## ==UI框架== 

- UGUI + MVC 

- UI管理堆栈，参数bool 是否压栈操作

- UI适配问题

- 常通用系统(==新手引导==,==红点系统==)     

- 常用的界面模型展示模块


---
## 定时回调任务


---

## 表格读取

基于lua热更，全部集中做lua的Table表格

自做工具导出（一键自动全部式，单文件式）


---
## 编辑器扩展
大多数为非编程人员提供便利操作


---

## 场景管理 

ScenesManager



---

## 日志系统 

Console pro + 自做日志系统



---

## 多语言 

国际化/本地化



---

## 热更新 

- tolua
- xlua



---

## SDK接入

- 账号性SDK 
- 功能性SDK 
- 数据中心 客户端侧上报（主要在服务器端）


---

## 自动发布构建

Jenkins 


---

## 项目优化

- CPU方向

  一、DC (DrawCalls) CPU调用底层图形接口

  1. Draw Call Batching 批处理，物体合并一个描绘来渲染

  ​			（1）Static Batching

  ​			（2）Dynamic Batching

  2. 纹理打包成图集，减少材质使用

  3. 尽量少的使用反光、阴影之类的效果，导致物体多次渲染

  二、物理组件 （Physics）

  1. 合适的Fixed Timestep

  2. 尽量不适用网格碰撞器

     性能优化角度，物理组件能少用则少用，不是不用

  三、GC(Garbage Collect)    

   1. 频繁GC会加重CPU的负担，GC是Mono运行时的机制，非Unity3D的引擎机制，GC针对Mono对象，管理Mono的托管堆

   2. GC不是来处理引擎的assets(纹理、音效)的内存释放的，Unity引擎也有自己的内存堆，不是和Mono一起使用所谓的托管堆

   3. 引用类型分配到托管堆（类的实例，字符串，数组），int，float，struct值类型是分配到堆栈上而不是堆上，==类实例，字符串，数组==关注对象

   4. GC的触发时机

      （1）堆内存不足自动调用

      （2）编程人员手动调用

  ​	

  四、代码质量 ==代码检测==    C#端 （PVSStudio），Lua端（？）C#和Lua 内存泄漏问题

- GPU方向


- 内存方向


---

## 线上日志查询(==错误==，==崩溃== 。。。)

- Bugly
- 日志发送到服务器
- 自身日志系统的彩蛋查看